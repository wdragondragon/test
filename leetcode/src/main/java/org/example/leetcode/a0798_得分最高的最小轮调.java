package org.example.leetcode;

/**
 * <p></p>
 * <p>create time: 2022/3/9 20:50 </p>
 *
 * @author : Jdragon
 */

/**
 * 本题考查知识点 > 这里参阅学习了bellyache大佬的思路：bellyache的 Leetcode 主页
 *
 * 思路：作为本题，我们很容易可以知道每次轮换使得当前值对应的下标会 -1，由此我们就可以知道如下几种情况：
 *
 * 1、如果在轮换之前当前对应的值大于此时的下标，那么轮换之后他就一定还是大于或者等于下标的，所以肯定还是处于之前的得分状态。
 *
 * 2、如果在轮换之前当前对应的值等于此时的下标，那么轮换之后他就一个会比下标小1 ，这是我们发现的每次轮换使得当前值对应下标会 -1得出来的。
 *
 * 3、如果在 轮换之前处于下标0位置的数 ，经过轮换之后该数 就会被轮换到数组的最后位置 ，此时无论处于数组第一个位置的该正整数的值是多少都是大于等于0的所以 会得分。
 *
 * 由上述三点的得分状态分析不同的转换次数的得分情况 记录最大得分的转换次数就可以求解。
 *
 * 我们很容易知道 score[k] = score[k-1] - ( k-1次轮换时此时下标等于下标对应值的个数 ) + 1 这个看起来就和动归的转换方程有点像啦，接着就是代码实现。
 *
 * 本地难点在于——如何求解 k-1次轮换时此时下标等于下标对应值的个数?
 *
 * 换一种思路就是相当于求当前k次循环时，下标等于下标对应值的元素个数。这里用数组moveCurVal2ValIdxStep[n] 来存储对应k次循环下，下标与下标对应值相等的元素个数。
 *
 * ⭐代码实现⭐ 动态规划+预处理
 */
public class a0798_得分最高的最小轮调 {
    public int bestRotation(int[] nums) {
        int val = 0,n = nums.length;
        // 定义的是一个经过k次轮换后 此时nums中的值与下标相等的个数
        int[] moveCurVal2ValIdxStep = new int[n];
        // 这里是用来找到 当前数组的当前值需要转换多少次才能到达对应其值的下标 至于为什么可以这样呢？ 这里不会越界么？
        // 题中给的提示告诉我们了 数组中的每个值都是小于数组长度的 0 <= nums[i] < nums.length 这样就不可能会越界
        for (int i = 0 ; i< n;i++){
            // 如果当前的值是大于下标的所以他肯定需要轮换到第一个之后再进行轮换才可能到达当前的值对应的下标
            // moveCurVal2ValIdxStep[i+n-nums[i]]++ 我们可以理解为当前数值需要轮换 ？ 次才能使得当前数值与下标相同
            // 使得在？次时的个数+1，即可遍历数组中每个数字需要经过？次轮换才能到达下标值与下标相同位置的个数啦~
            if (nums[i] > i)moveCurVal2ValIdxStep[i + n - nums[i]]++;
                // 这里是如果我们当前的下标都大于或者等于当前值了，
                //我们就直接计算轮换 i - nums[i] 次就可以使得我们的当前值得下标 = 当前值
            else moveCurVal2ValIdxStep[i-nums[i]]++;
        }
        int k = 0 ,maxVal = val;
        for (int i = 1;i< n;i++){
            // 状态转换方程 dp[i] = dp[i-1] + (k-1次轮换时此时下标等于下标对应值的个数
            // 即 下标0时 nums[0] = 0的情况下) + 1 (这里为什么要加1呢
            // 因为当我们第一个的值转换后就会到数组的最后一个位置此时最后位置的数值一定是大于等于 0 的所以需要+1)
            val = val - moveCurVal2ValIdxStep[i-1] + 1;
            // 通过滚动变量val 找到最大值记录当前的转换次数k 得到转换 k 次能得到最大的分数
            if (val > maxVal){
                maxVal = val;
                k = i;
            }
        }
        return k;
    }
}
